<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DUEL: EXPLOSIVE</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        body {
            margin: 0; overflow: hidden;
            background-color: #120024;
            font-family: 'Courier New', Courier, monospace;
            cursor: none; user-select: none;
        }

        /* --- UI OVERLAYS --- */
        .overlay {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 0, 30, 0.95);
            border: 2px solid #00ffff;
            box-shadow: 0 0 20px #00ffff, inset 0 0 20px #00ffff;
            padding: 40px; width: 320px;
            text-align: center; color: #fff; z-index: 100;
        }
        h1 { margin: 0 0 20px 0; text-transform: uppercase; letter-spacing: 4px; color: #ff00ff; text-shadow: 2px 2px #00ffff; }
        button {
            width: 100%; padding: 15px; margin-bottom: 10px;
            background: #000; border: 1px solid #ff00ff;
            color: #ff00ff; font-family: inherit; font-size: 16px; font-weight: bold;
            cursor: pointer; transition: 0.2s; text-shadow: 0 0 5px #ff00ff;
        }
        button:hover { background: #ff00ff; color: #000; box-shadow: 0 0 15px #ff00ff; }
        input {
            width: 90%; padding: 10px; margin-bottom: 15px;
            background: #110022; border: 1px solid #00ffff; color: #00ffff;
            text-align: center; font-family: inherit; font-size: 14px;
        }
        .hidden { display: none !important; }

        /* --- HUD --- */
        #hud { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        #score-container {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            font-size: 30px; font-weight: bold; color: #fff;
            text-shadow: 0 0 10px #00ffff; letter-spacing: 3px;
        }
        #score-val { color: #00ffff; }

        #hp-container {
            position: absolute; bottom: 30px; left: 30px;
            width: 300px; height: 15px;
            background: rgba(20, 0, 30, 0.5); border: 1px solid #ff00ff;
            transform: skewX(-20deg); box-shadow: 0 0 10px #ff00ff;
        }
        #hp-bar { width: 100%; height: 100%; background: #ff00ff; transition: width 0.1s; }
        #hp-label { position: absolute; top: -20px; left: 0; font-size: 12px; color: #ff00ff; }

        /* --- CROSSHAIR --- */
        #crosshair {
            position: absolute; width: 50px; height: 50px;
            border: 2px solid #00ffff; border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 50;
            box-shadow: 0 0 10px #00ffff; transition: width 0.1s, height 0.1s;
        }
        #crosshair.active { width: 30px; height: 30px; background: rgba(0, 255, 255, 0.2); }
        #crosshair-dot {
            position: absolute; top: 50%; left: 50%; width: 4px; height: 4px;
            background: #fff; transform: translate(-50%, -50%); box-shadow: 0 0 5px #fff;
        }

        #flash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #ff0000; opacity: 0; pointer-events: none; transition: opacity 0.1s; z-index: 40;
            mix-blend-mode: overlay;
        }
    </style>
</head>
<body>

    <div id="crosshair"><div id="crosshair-dot"></div></div>
    <div id="flash"></div>

    <div id="hud" class="hidden">
        <div id="score-container">SCORE: <span id="score-val">0</span> / 25</div>
        <div id="hp-container">
            <span id="hp-label">SHIELD STATUS</span>
            <div id="hp-bar"></div>
        </div>
    </div>

    <div id="menu-main" class="overlay">
        <h1>NEON DUEL</h1>
        <button onclick="startSolo()">SOLO MISSION</button>
        <button onclick="setupHost()">HOST GAME</button>
        <button onclick="setupJoin()">JOIN GAME</button>
    </div>

    <div id="menu-host" class="overlay hidden">
        <h3>HOST ID</h3>
        <input type="text" id="host-id-display" readonly onclick="this.select(); document.execCommand('copy')">
        <p style="font-size: 12px; color: #00ffff;">Share code with Player 2</p>
        <button onclick="location.reload()">CANCEL</button>
    </div>

    <div id="menu-join" class="overlay hidden">
        <h3>ENTER HOST ID</h3>
        <input type="text" id="join-id-input">
        <button onclick="connectToHost()">CONNECT</button>
        <button onclick="location.reload()">BACK</button>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    // --- AUDIO SYSTEM ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const ac = new AudioContext();

    function playSound(type) {
        if (ac.state === 'suspended') ac.resume();
        const t = ac.currentTime;
        const gain = ac.createGain();
        gain.connect(ac.destination);

        if (type === 'shoot') {
            const osc = ac.createOscillator();
            osc.frequency.setValueAtTime(800, t);
            osc.frequency.exponentialRampToValueAtTime(100, t + 0.15);
            osc.connect(gain);
            gain.gain.setValueAtTime(0.3, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
            osc.start(); osc.stop(t + 0.15);
        } else if (type === 'hit') {
            // Shatter Sound
            const osc = ac.createOscillator();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(200, t);
            osc.frequency.exponentialRampToValueAtTime(50, t + 0.3);
            osc.connect(gain);
            gain.gain.setValueAtTime(0.4, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
            osc.start(); osc.stop(t + 0.3);
        } else if (type === 'damage') {
            const osc = ac.createOscillator();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, t);
            osc.frequency.exponentialRampToValueAtTime(10, t + 0.2);
            osc.connect(gain);
            gain.gain.setValueAtTime(0.5, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
            osc.start(); osc.stop(t + 0.2);
        }
    }

    // --- ENGINE SETUP ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    let W, H;
    const resize = () => { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; };
    window.addEventListener('resize', resize);
    resize();

    // --- GAME STATE ---
    let mode = 'menu';
    let peer = null, conn = null;
    const keys = { a:false, d:false, left:false, right:false, up:false, down:false, enter:false };
    const mouse = { x: W/2, y: H/2 };

    const player = { x: 0, hp: 100, recoil: 0, flash: 0, score: 0 };
    const ENEMY_SCALE = 0.6; // Scale up for "Closer" feel (0.2 was far, 0.6 is close)
    
    let enemies = [];
    let enemyBullets = []; 
    let laserBeams = []; 
    let particles = []; // Explosion shards
    let lastSpawn = 0;

    // Synthwave BG
    let gridOffset = 0;
    let buildings = [];
    function initCity() {
        buildings = [];
        for(let i=0; i<40; i++) {
            let side = i % 2 === 0 ? -1 : 1;
            buildings.push(createBuilding(side, Math.random() * 1000));
        }
    }
    function createBuilding(side, zPos) {
        return {
            x: side * (300 + Math.random() * 200),
            z: zPos,
            width: 100 + Math.random() * 150,
            height: 200 + Math.random() * 400,
            color: Math.random() > 0.5 ? '#00ffff' : '#ff00ff',
            windows: Math.random()
        };
    }
    initCity();

    // --- INPUT ---
    window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; 
        const ch = document.getElementById('crosshair'); ch.style.left = mouse.x + 'px'; ch.style.top = mouse.y + 'px'; 
    });
    window.addEventListener('keydown', e => { 
        if(e.key.toLowerCase() in keys) keys[e.key.toLowerCase()] = true; 
        if(e.key.startsWith('Arrow')) keys[e.key.slice(5).toLowerCase()] = true;
        if(e.key === 'Enter') keys.enter = true;
    });
    window.addEventListener('keyup', e => { 
        if(e.key.toLowerCase() in keys) keys[e.key.toLowerCase()] = false; 
        if(e.key.startsWith('Arrow')) keys[e.key.slice(5).toLowerCase()] = false;
        if(e.key === 'Enter') keys.enter = false;
    });

    // --- SHOOTING LOGIC ---
    window.addEventListener('mousedown', () => {
        if (mode === 'menu' || player.hp <= 0 || mode === 'client') return;

        player.recoil = 20;
        player.flash = 3;
        playSound('shoot');

        laserBeams.push({ x: mouse.x, y: mouse.y, alpha: 1.0 });

        let hitMade = false;
        const cx = W / 2; 
        const cy = H / 2;
        const camOffset = -player.x;

        // Check Hit
        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i];
            
            const scale = ENEMY_SCALE;
            const screenX = cx + (e.x + camOffset) * scale;
            const screenY = cy + (e.y) * scale;
            const size = 70 * scale;

            if (mouse.x > screenX - size/2 && mouse.x < screenX + size/2 &&
                mouse.y > screenY - size/2 && mouse.y < screenY + size/2) {
                
                // HIT & KILL
                hitMade = true;
                
                createExplosion(screenX, screenY, e.color); // Spawn particles at screen position
                
                enemies.splice(i, 1);
                player.score += 5;
                playSound('hit');
                updateScoreUI();
                break;
            }
        }

        if (mode === 'host' && conn) {
            conn.send({ type: 'shot', hit: hitMade });
        }
        
        checkWin();
    });

    function createExplosion(x, y, color) {
        // Spawn 30 particles
        for(let i=0; i<30; i++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 15, // High velocity
                vy: (Math.random() - 0.5) * 15,
                size: Math.random() * 6 + 2,
                color: color,
                life: 1.0 // Alpha
            });
        }
    }

    // --- GAME LOOP ---
    function update() {
        if (player.hp <= 0) return;

        const speed = 6;
        if (keys.a) player.x = Math.max(-300, player.x - speed);
        if (keys.d) player.x = Math.min(300, player.x + speed);

        // Env Animation
        gridOffset = (gridOffset + speed) % 100;
        buildings.forEach(b => { b.z -= speed; if(b.z < -100) Object.assign(b, createBuilding(b.x > 0 ? 1 : -1, 1000 + Math.random()*100)); });

        // Enemy Logic
        if (mode === 'solo') {
            const now = Date.now();
            if (now - lastSpawn > 1500) { 
                spawnEnemy(); 
                lastSpawn = now; 
            }
            enemies.forEach(e => {
                e.x += Math.sin(now / e.seed) * 3;
                e.y += Math.cos(now / e.seed) * 2;
                if (now - e.lastShot > 2000 && Math.random() < 0.03) {
                    fireEnemyBullet(e);
                    e.lastShot = now;
                }
            });
        }
        else if (mode === 'client') {
            if (enemies.length === 0) spawnEnemy(true);
            const boss = enemies[0];
            if (boss) {
                if(keys.left) boss.x -= 8; if(keys.right) boss.x += 8;
                if(keys.up) boss.y -= 8; if(keys.down) boss.y += 8;
                if(keys.enter && Date.now() - boss.lastShot > 400) {
                    boss.lastShot = Date.now();
                    fireEnemyBullet(boss);
                    if(conn) conn.send({ type: 'bossShoot' });
                }
                if(conn) conn.send({ type: 'bossMove', x: boss.x, y: boss.y });
            }
        }

        // Bullets
        for (let i = enemyBullets.length - 1; i >= 0; i--) {
            let b = enemyBullets[i];
            b.z -= b.vz; 
            const progress = (1000 - b.z) / 1000;
            b.currX = b.startX + (b.tx - b.startX) * progress;
            b.currY = b.startY + (b.ty - b.startY) * progress;

            if (b.z <= 0) {
                if (Math.abs(b.currX - player.x) < 50) {
                    player.hp -= 10;
                    playSound('damage');
                    document.getElementById('flash').style.opacity = 0.8;
                    setTimeout(() => document.getElementById('flash').style.opacity = 0, 100);
                    if (player.hp <= 0) endGame("CRITICAL FAILURE - ENEMY WINS");
                }
                enemyBullets.splice(i, 1);
            }
        }

        // Particles (Explosions)
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.03; // Wither speed
            if (p.life <= 0) particles.splice(i, 1);
        }

        // Host Sync
        if(mode === 'host' && conn) {
            conn.send({ type: 'state', px: player.x, php: player.hp, enemies: enemies, bullets: enemyBullets });
        }
        
        document.getElementById('hp-bar').style.width = player.hp + '%';
    }

    function spawnEnemy(isBoss=false) {
        enemies.push({
            x: (Math.random() - 0.5) * 600,
            y: (Math.random() - 0.5) * 300,
            seed: 300 + Math.random() * 500,
            lastShot: Date.now(),
            color: isBoss ? '#ff0000' : (Math.random()>0.5 ? '#ff00ff' : '#00ffff')
        });
    }

    function fireEnemyBullet(e) {
        enemyBullets.push({
            startX: e.x, startY: e.y,
            z: 1000,
            tx: player.x,
            ty: 0,
            vz: 15
        });
        playSound('enemy_shoot');
    }

    function updateScoreUI() { document.getElementById('score-val').innerText = player.score; }
    function checkWin() { if (player.score >= 25) endGame("TARGET THRESHOLD REACHED - YOU WIN"); }
    function endGame(msg) { alert(msg); location.reload(); }

    // --- RENDERER ---
    function draw() {
        const bgGrad = ctx.createLinearGradient(0, 0, 0, H);
        bgGrad.addColorStop(0, '#0a001a'); bgGrad.addColorStop(1, '#2a004a');
        ctx.fillStyle = bgGrad; ctx.fillRect(0, 0, W, H);

        const cx = W/2; const cy = H/2; const camOffset = -player.x;

        // Animated Grid
        ctx.strokeStyle = '#ff00ff'; ctx.lineWidth = 1; ctx.globalAlpha = 0.5;
        ctx.beginPath();
        for (let i = -1500; i <= 1500; i += 150) { ctx.moveTo(cx + (i + camOffset) * 2, H); ctx.lineTo(cx + (i * 0.1), cy); }
        for (let i = 0; i < H / 2; i += 25) {
            let y = cy + ((i + gridOffset) % (H/2)); 
            let p = (y - cy) / (H/2);
            let wScale = 0.1 + p*2.5;
            ctx.moveTo(cx - W*wScale + camOffset*p, y); ctx.lineTo(cx + W*wScale + camOffset*p, y);
        }
        ctx.stroke(); ctx.globalAlpha = 1;

        // City
        buildings.sort((a,b) => b.z - a.z);
        buildings.forEach(b => {
            const depth = b.z / 1000; const scale = 1.0 - (depth * 0.8);
            if(scale <= 0) return;
            const sx = cx + (b.x + camOffset) * scale;
            const sw = b.width * scale; const sh = b.height * scale;
            const sy = cy - sh;
            ctx.fillStyle = '#000'; ctx.fillRect(sx - sw/2, sy, sw, sh);
            ctx.strokeStyle = b.color; ctx.lineWidth = 2; ctx.strokeRect(sx - sw/2, sy, sw, sh);
        });

        // Enemies
        enemies.forEach(e => {
            const scale = ENEMY_SCALE; // BIGGER
            const sx = cx + (e.x + camOffset) * scale;
            const sy = cy + (e.y) * scale;
            const size = 70 * scale;

            ctx.shadowBlur = 15; ctx.shadowColor = e.color;
            ctx.fillStyle = e.color; ctx.fillRect(sx - size/2, sy - size/2, size, size);
            ctx.strokeStyle = '#fff'; ctx.strokeRect(sx - size/2, sy - size/2, size, size);
            ctx.shadowBlur = 0;
            
            // Aim Highlight
            if (mouse.x > sx - size/2 && mouse.x < sx + size/2 &&
                mouse.y > sy - size/2 && mouse.y < sy + size/2) {
                document.getElementById('crosshair').classList.add('active');
            } else {
                document.getElementById('crosshair').classList.remove('active');
            }
        });

        // Bullets
        enemyBullets.forEach(b => {
            const depth = b.z / 1000; const scale = 1.0 - (depth * 0.9);
            const sx = cx + (b.currX + camOffset) * scale;
            const sy = cy + (b.currY) * scale;
            const size = 15 * scale;
            ctx.fillStyle = '#ff0000'; ctx.shadowBlur = 10; ctx.shadowColor = '#ff0000';
            ctx.beginPath(); ctx.arc(sx, sy, size, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 0;
        });

        // Particles (Explosions)
        particles.forEach(p => {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x, p.y, p.size, p.size);
        });
        ctx.globalAlpha = 1;

        // Player Lasers
        ctx.lineWidth = 3;
        for(let i=laserBeams.length-1; i>=0; i--) {
            let b = laserBeams[i];
            ctx.strokeStyle = `rgba(0, 255, 255, ${b.alpha})`;
            ctx.shadowBlur = 10; ctx.shadowColor = '#00ffff';
            ctx.beginPath();
            const gunX = W * 0.7 + (mouse.x - cx) * 0.08;
            const gunY = H - player.recoil + 50; 
            ctx.moveTo(gunX, gunY); ctx.lineTo(b.x, b.y); ctx.stroke();
            b.alpha -= 0.1; if(b.alpha <= 0) laserBeams.splice(i, 1);
        }
        ctx.shadowBlur = 0;

        // Gun
        const gunX = W * 0.7 + (mouse.x - cx) * 0.08; const gunY = H - player.recoil + 20; if (player.recoil > 0) player.recoil *= 0.8;
        ctx.save(); ctx.translate(gunX, gunY);
        ctx.fillStyle = '#111'; ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 2; ctx.shadowBlur = 10; ctx.shadowColor = '#00ffff';
        ctx.beginPath(); ctx.moveTo(-30, 0); ctx.lineTo(-20, -180); ctx.lineTo(20, -180); ctx.lineTo(40, 0); ctx.fill(); ctx.stroke();
        if (player.flash > 0) { ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0, -190, 40, 0, Math.PI*2); ctx.fill(); player.flash--; }
        ctx.restore();
    }

    function loop() { update(); draw(); requestAnimationFrame(loop); }

    // --- NETWORKING ---
    function startSolo() { mode = 'solo'; document.getElementById('menu-main').classList.add('hidden'); document.getElementById('hud').classList.remove('hidden'); loop(); }
    function setupHost() { mode = 'host'; document.getElementById('menu-main').classList.add('hidden'); document.getElementById('menu-host').classList.remove('hidden'); peer = new Peer(); peer.on('open', id => document.getElementById('host-id-display').value = id); peer.on('connection', c => { conn = c; conn.on('open', () => { document.getElementById('menu-host').classList.add('hidden'); document.getElementById('hud').classList.remove('hidden'); loop(); }); conn.on('data', d => { if(d.type === 'bossMove') { if(enemies.length === 0) spawnEnemy(true); enemies[0].x = d.x; enemies[0].y = d.y; } if(d.type === 'bossShoot') { if(enemies.length > 0) fireEnemyBullet(enemies[0]); } }); }); }
    function setupJoin() { mode = 'client'; document.getElementById('menu-main').classList.add('hidden'); document.getElementById('menu-join').classList.remove('hidden'); }
    function connectToHost() { const id = document.getElementById('join-id-input').value; peer = new Peer(); peer.on('open', () => { conn = peer.connect(id); conn.on('open', () => { document.getElementById('menu-join').classList.add('hidden'); document.getElementById('hud').classList.remove('hidden'); loop(); }); conn.on('data', d => { if(d.type === 'state') { player.x = d.px; player.hp = d.php; enemies = d.enemies; enemyBullets = d.bullets; } if(d.type === 'sound') playSound(d.id); }); }); }

</script>
</body>
</html>